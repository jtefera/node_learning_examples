<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>README</title></head><body><article class="markdown-body"><p>BASIC NOTES ON NODE.JS / SPANGLISH</p>
<hr />
<h1 id="01-basic-iniciar-un-servidor-basico"><a name="user-content-01-basic-iniciar-un-servidor-basico" href="#01-basic-iniciar-un-servidor-basico" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>01 Basic: Iniciar un servidor básico:</h1>
<pre><code>//en basic.js
//Required modules.
var http = require(&quot;http&quot;);

    //Creating an HTTP the server that listens to the port 8081
    http.createServer(function (request,response){
        //Request is the data sent to the server
        //Response is the data sent from the server to the client
        //Respondemos enviando un header con el status(200, todo correccto)
        //y el tipo de archivo
        response.writeHead(200, {&quot;Content-type&quot;:&quot;text/plain&quot;});

        //Escribir un Hello world a todas las páginas que aparecen y 
        //cerrar la respuesta al cliente
        response.end(&quot;Hello world :)&quot;);
    }).listen(8081);

//Notificación que se envia a la consola del servidor y no a la del cliente
console.log(&quot;Servidor creado&quot;);
</code></pre>

<pre><code>//En terminal
node server.js
</code></pre>

<h1 id="02-basic-modules-iniciar-un-paquete-en-npm"><a name="user-content-02-basic-modules-iniciar-un-paquete-en-npm" href="#02-basic-modules-iniciar-un-paquete-en-npm" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>02 Basic Modules: Iniciar un paquete en npm</h1>
<pre><code>//en terminal
npm init

//Rellenar datos que pediran

//Tras rellendado datos, añadirnos como usuarios
npm adduser
//Pedira username, contraseña y email

//Publicar al repositiorio de modulos de npm. 
//Si no va, comprobar que el nombre no está usado
npm publish
</code></pre>

<h1 id="03-readfile-reading-a-file-async"><a name="user-content-03-readfile-reading-a-file-async" href="#03-readfile-reading-a-file-async" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>03 ReadFile: Reading a file async</h1>
<pre><code>//en readFileTut.js
//To create a server if needed
var http = require(&quot;http&quot;);

//TO read and write files
var fs = require(&quot;fs&quot;);

//Async function to read files,
//Path to file, func for err and data
//See how all callback function receive err and data inputs
fs.readFile(&quot;index.txt&quot;, function(err, data){
    if(err) return console.err(err);
    console.log(data.toString());
});

//ProgramEnded
console.log(&quot;Finished!&quot;);
</code></pre>

<h1 id="04-events"><a name="user-content-04-events" href="#04-events" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>04 Events</h1>
<p>Node is an event driven language. We build multiple observers for different kinds of events and when one is emmited, the function adhered to the oberved is called. Events can be a client connection, a get request, a change in a state, etc. Node has also the ability to create its own events and fire them at please. For that it uses the events module:</p>
<pre><code>//In a file
//Require events, in-build with node, no need to install
var events = require(&quot;events&quot;);
//Require HTTP for server purposes
var http = require(&quot;http&quot;);

//Creating the event emmiter object. It handles all the events
var eventEmitter = new event.eventEmitter();

//Function to emit when the event &quot;connection&quot; is fired:
function sayHello(){
    console.log(&quot;Hello&quot;);
    //Fires the &quot;data_received&quot; event
    eventEmitter.emit(&quot;data_received&quot;);
}

//Creates a &quot;connection&quot; event and binds it with the function sayHello
eventEmitter.on(&quot;connection&quot;, sayHello);

//Creates the event &quot;data_received&quot; and binds it with an anon function
eventEmitter.on(&quot;data_received&quot;,function(){
   console.log(&quot;Data received!&quot;);
});

//Server creation listening in port 8081
http.createServer(function(request,response) {
    //Send header with the following info:
    //Status: 200, all correct
    //Connection-type: text
    response.writeHead(200, {&quot;Connection-type&quot;: &quot;text/plain&quot;});

    //Send &quot;Hello&quot; in the webpage and end the connection
    response.end(&quot;Hello World!&quot;);

    //Fire the &quot;connection&quot; event
    eventEmitter.emit(&quot;connection&quot;);
});
</code></pre>

<h3 id="eventemitter-methods"><a name="user-content-eventemitter-methods" href="#eventemitter-methods" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>EventEmitter methods:</h3>
<p>-addListener(event, listener): es igual que on(event, listener). Tanto on como addListener devuelven el eventEmitter por lo que se pueden encadenar varios a la vez; Lanza el newListener event<br />
-on(event, listenr): Igual que addListener<br />
-once(event, listener): El listener es ejecutado solo la primera vez que el event es fired. Tras ello es removido. Devuelve emitter<br />
-removeListener(event, listener): quita un listener del event. Devuelve eventEmitter. Lanza el removeListener event. Para poder removerlo, el listener en addListener o en on debe ser una función no anonima. El listener en removeListener será por tanto el nombre de dicha función.<br />
-setMaxListeners(n): Por defecto, node da un warning si hay más de 10 listener para un evento dado. Con setMaxListeners se puede aumentar o decrementar dicho número. 0 para ilimitado.<br />
-listeners(event): devuelve lista de listeners para un elemento dado<br />
-emit(event, [arg1], [arg2], &hellip;): Lanza un elemento con argumentos opcionales. Devuelve true si el evento tenía listers y falso en cao contrario.  </p>
<h3 id="funciones-que-aceptan-eventemitters"><a name="user-content-funciones-que-aceptan-eventemitters" href="#funciones-que-aceptan-eventemitters" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Funciones que aceptan eventEmitters:</h3>
<p>-listenerCount(emmiter, event): devuelve el número de listeners para un evento dado. No recomendado. Mejor </p>
<h3 id="eventos-que-son-lanzados"><a name="user-content-eventos-que-son-lanzados" href="#eventos-que-son-lanzados" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Eventos que son lanzados:</h3>
<p>-newListener: Se lanza cada vez que un listener es añadido. Devuelve nombre del event y la función listener. El evento es lanzado antes que el listener es añadido al event. Eso hace que podamos añadir otro listener antes que dicho event con once(basado en el código anterior):</p>
<p><pre><code>//Lanzado una vez cuando un evento es enviado
//(con on o addListener, no es lo mismo que emit)
eventsEmitter.once(&quot;newListener&quot;, function(event, listenr){
    //Vamos a añadir un nuevo listener al evento myEvent
   if(event == &quot;myEvent&quot;) {
    //Solo estamos haciendo un binding y no lo estamos emitiendo.
    //El listener no es llamado ahora sino cuanod el evento &quot;myEvent&quot; sea emitido
     eventsEmitter.on(&quot;myEvent&quot;, function(){
       console.log(&quot;Esto saldrá antes que el listener del myEvent de abajo&quot;);
    });
   }
});

//Lanza el &quot;newListener&quot; event
eventEmitter.on(&quot;myEvent&quot;, function() {
    //Los listeners para un evento están dentro de un array.
    //Cada vez que se añade un listener se añade a la cola de dicho array.
    //Cuando el evento es emitido, node va ejecutando los listeners de arriba 
    //a abajo.
    //El listener del evento &quot;newListener&quot; es ejectuado antes 
    //de que se añada este listener a myEvents por lo que el listener añadido a
    //myEvents anteriormente es añadido antes que este listener
   console.log(&quot;Apareceré más abajo&quot;);
});        
eventEmmiter.emit(&quot;myEvent&quot;);
</code></pre><br />
-removeListener: Evento que se lanza cada vez que se elimina un listener. Devuelve event(string) y listener(func).</p>
<h1 id="buffers"><a name="user-content-buffers" href="#buffers" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Buffers</h1>
<p>Javascript tiene problemas para tratar datos binarios que le van llegando, por ejemplo, desde una conexión TCP. Con dichas conexiones, la información que se trata es raw, es decir, streams(o flujo) de datos binarios. Para tratar la información con facildad en javascript, hay que transformar dichos datos binarios en codificación unicode(utf8 entre otros). Cada caracter en utf8 viene codificado de una serie de 8 bits. Por lo tanto, lo que se suele hacer es guardar los binarios en sus octetos correspondiendes y codificarlos. Para guardar los bits hasta que el octeto esté completo, se hace uso de buffers que es una región de memoria encargada de guardar datos temporarmente mientras se pasa de un lado(TCP stream) a otro (funciones en javascript). Dicho buffer en Node actua como un array de dimensión dada. Cada elemento de dicho array contiene un octeto.</p>
<p>Para crear el buffer:<br />
<pre><code>//buffer formado por un array de dimensión 10
//Este modo crea el array con los buffer sin inicializar
var buf = new buffer(10);
</code></pre><br />
Otro método viene dado por<br />
<pre><code>//buffer incialziado con un array
var buf = new buffer([10, 20, 15, 30]);
</code></pre><br />
Otro método es crear un buffer a través de un string y su codificación. Este método por tanto, transforma dicho string en un array de octetos binario correspondiendes a la codificación dada:<br />
<pre><code>//El encoding es opcional ya que por defecto se asume utf-8
var buf = new buffer(&quot;Hello World&quot;, &quot;utf8&quot;);
</code></pre></p>
<p>Para poder escribir sobre el buffer:<br />
<pre><code>//creamos un buffer con capacidad de 256 octetos(correspodientes a 256 caracteres en utf8)
var buf = new buffer(256);
</code></pre><br />
write(str, [codificación]) codifica el string a utf8 o la encodación dada(si es que es dada). Graba solo los primeros 256 carácteres. Devuelve el número de octetos escritos</p>
<pre><code>var len = buf.write(&quot;Hola mundo&quot;);
</code></pre>

<p>Para poder leer desde el buffer:<br />
<pre><code>//Creamos un buffer desde un string
var buf = new buffer(&quot;hola mundo&quot;);
//Para leer usamos toString([codificación || &quot;utf8&quot;], [beg], [end]);
console.log(buf.toString()); //hola mundo
console.log(buf.toString(&quot;utf8&quot;, 1)); //ola mundo
console.log(buf.toString(undefined, 1, 6)); //ola m
</code></pre></p>
<p>Concatenar buffers:<br />
<pre><code>var buf1 = new Buffer(&quot;Hola &quot;);
var buf2 = new Buffer(&quot;Mundo!&quot;);

//Buffer.concat(lista_de_buffers, [longTotalDelNuevoBufferCreado])
var buf3 = Buffer.concat(buf1, buf2);
console.log(buf3.toString());   //Hola Mundo!
</code></pre></p>
<p>Comparar buffers:<br />
    Compara por ordén el texto de dos buffers(en utf8 cod) ABC &gt; ab8; ba &lt; AB ya que el cod utf8 de las letras minusculas es menor que el de las mayusculas:</p>
<pre><code>var buf1 = new Buffer(&quot;Hola&quot;);
var buf2 = new Buffer(&quot;tola&quot;);
var buf3 = new Buffer(&quot;hola&quot;);
var buf4 = new Buffer(&quot;Hol&quot;);
var buf5 = new Buffer(&quot;Hol&quot;);

//Por orden buf3 &lt; buf2 &lt; buf4 == buf5 &lt; buf1
//buf1.compare(buf2) devuelve -1 si buf1 &lt; buf2, 0 si buf1 === buf2, 1 si buf1 &gt; buf2
console.log(buf4.compare(buf1)); // -1
console.log(buf4.compare(buf2)); // 1
console.log(buf4.compare(buf5)); // 0
</code></pre>

<p>Copiar buffer:<br />
<pre><code>//Copia sourceBuf desde la pos sourceStart hasta sourceEnd en targetBuf a partir de su pos targetStart
//Modifica targetBuf. No devuelve nada
//sourceBuf.copy(targetBuf,[targetStart], [sourceStart], [sourceEnd]);
sourceBuf.copy(targetBuf);
</code></pre></p>
<p>Slice(Devolve un sub-buffer):<br />
<pre><code>//Devuelve un nuevo buffer formado de extraer(sin modificar) parte de un buffer:
// buf.slice([start], [end]);
var subBuf = buf.slice();//Devuelve todo
var subBuf2 = buf.slice(2,4);
</code></pre></p>
<p>Buf length: buf.length</p>
<p>Otros métodos importantes:</p>
<ul>
<li>
<p>buf.fill(value, [beg], [end]);<br />
··· Rellena un buffer desde beg hasta end con el valor value: buf.fill(0) es usado cuando se ha creado buf con new Buffer(10), para rellenar los 10 elementos con 0 en vez de el aleatorio con el que son comenzados.</p>
</li>
<li>
<p>Metodos de clase Buffer:<br />
··· Buffer.isEncoding(enc)</p>
</li>
</ul>
<p>Nos dice si enc es un tipo de encoding:<br />
<pre><code>    Buffer.isEncoding(&quot;utf8&quot;) //true
    Buffer.isEncoding(&quot;utf-8&quot;) //true
    Buffer.isEncoding(&quot;utf/8&quot;) //false
</code></pre></p>
<p>··· Buffer.isBuffer(obj)<br />
···· Nos dice si obj es un objeto buffer.<br />
··· Buffer.byteLength(str, [encoding])<br />
···· Nos dice el número de byts usados para str en la encodiacion [encoding || &ldquo;utf8&rdquo;]</p>
<h1 id="05-streams"><a name="user-content-05-streams" href="#05-streams" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>05 Streams!!</h1>
<p>Dentro de Node, podemos recibir y escribir datos de muchas fuentes distintas. Sease de conexiones HTTP, de TCPs, de archivos, etc. Cada uno de estos es un stream que genera un flujo de datos. Node nos permite trabajar sobre dicho flujo sin esperar a concentrarlo todo.</p>
<p>Los streams pueden ser:<br />
<em> Readable: de lectura<br />
</em> Writeble: de escritura<br />
<em> Duplex: de escritura/lectura<br />
</em> Transform: un duplex en el que el output depende del input</p>
<p>Cada stream es un eventEmitter por lo que lanzan eventos. Los eventos que se lanzan son:<br />
<em> data: Es lanzado cuando hay datos disponibles para lectura<br />
</em> end: Es lanzado cuando no hay más datos de lectura en el stream<br />
<em> error: Es lanzado cuando ha habido un error en la lectura o escritura<br />
</em> finish: Es lanzado cuando todos los datos se han enviado ya</p>
<p>Lectura:<br />
<pre><code>//readSt.js
//Vamos a crear un stream a partir de la lectura
// de un archivo existente en el directoorio llamado readMyStream.txt

//Requerimos del modulo de lectura de archivos
var fs = require(&quot;fs&quot;);

//Contendrá los datos que vayamos leyendo
var data = &quot;&quot;;

//Creamos un stream desde el que podremos leer:
var readerStream = fs.createReadStream(&quot;readMyStream.txt&quot;);

//Designamos el encoding para dicho texto:
readerStream.setEncoding(&quot;utf8&quot;);

//Asignamos un listener a dicho stream para cuando llegan datos
//Los datos van llegando en cachos desde el buffer
readerStream.on(&quot;data&quot;, function(chunkOfData) {
    data += chuckOfData;
});

//Cuando acabamos de leer los datos del archivo, los devolvemos a la consola
//Asignamos un listener al evento &quot;end&quot; que se lanza cuando se ha acabado la lectura
readerStream.on(&quot;end&quot;, function(){
    console.log(data);
});

//Asignamos un listener al caso de tener errores
readerStream.on(&quot;error&quot;, function(err){
    console.log(err.stack);
});
</code></pre></p>
<p>Escritura:<br />
<pre><code>//writeSt.js
//Creareamos un stream que escribira sobre el archivo writeMe.txt

//Requerimos de fs
var fs = require(&quot;fs&quot;);

//Datos a ecribir
var data = &quot;Adios Mi Amor&quot;;

//Creamos un writable stream. Si no existe el archivo, lo crea.
var writableStream = fs.createWriteStream(&quot;writeMe.txt&quot;);

//Escribimos en dicho stream
writableStream.write(data, &quot;UTF8&quot;);

//Cerramos dicho stream
writableStream.end();

//Creamos un listener para cuando se acabe de escribir:
writableStream.on(&quot;finish&quot;, function(){
   console.log(&quot;Datos escritos!&quot;);
});

//En caso de error
writableStream.on(&quot;error&quot;, function(err){
   console.log(err.stack);
});
</code></pre></p>
<p>Piping:<br />
* Un modo eficiente para tratar con stream es el método de piping en el que se concatenan distintos streams de modo que el output de uno de ellos es el input del siguiente. De este modo podemos ir leyendo un stream y pasar los chucks a un stream de escritura que los va escribiendo. También podemos poner un pipe en medio que modifique el primer pipe antes de pasarlo al de escritura.<br />
<pre><code>//piping.js
//Leemeos desde readMyStream.txt y escribimos en writtedWithPipe.txt
//Requerimos fs para lectura escritura de datos
var fs = require(&quot;fs&quot;);

//Stream de lectura desde readMyStream.txt
var readStream = fs.createReadStream(&quot;readMyStream.txt&quot;);

//Stream de escritura en writtedWithPipe.txt
var writeStream = fs.createWriteStream(&quot;writtedWithPipe.txt&quot;);

//Escribir en write lo que leemos en read
readStream.pipe(writeStream);
</code></pre></p>
<p>Compressing data:<br />
    A través del mismo metodo de piping, podemos usar entre medias entre el stream de lectura y el de escritura una función que comprima.<br />
    Para ello usaremos el módulo in-built zlib que comprime archivos a través de la función createGzip() en formato gz<br />
<pre><code>//compress.js
//Leemeos desde readMyStream.txt, comprimimos y escribimos en readMyStream.txt.gz
//Requerimos fs para lectura escritura de datos
var fs = require(&quot;fs&quot;);
//Libreria zlib que ya viene con node
var zlib = require(&quot;zlib&quot;);

//Stream de lectura desde readMyStream.txt
var readStream = fs.createReadStream(&quot;readMyStream.txt&quot;);

//Stream de escritura en writtedWithPipe.txt
var writeStream = fs.createWriteStream(&quot;readMyStream.txt.gz&quot;);

//El stream de lectura lo pasamos por la función de compresión que crea un stream que lo pasamos al stream de escritura
readStream.pipe(zlib.createGzip())
          .pipe(writeStream);
</code></pre></p>
<p>Uncompressing data:<br />
    Efecto contrario<br />
<pre><code>//uncompress.js
//Leemeos desde readMyStream.txt.gz, descomprimimos y escribimos en readMyStreamDesc.txt
//Requerimos fs para lectura escritura de datos
var fs = require(&quot;fs&quot;);
//Libreria zlib que ya viene con node
var zlib = require(&quot;zlib&quot;);

//Stream de lectura desde readMyStream.txt.gz
var readStream = fs.createReadStream(&quot;readMyStream.txt.gz&quot;);

//Stream de escritura en readMyStreamDesc.txt
var writeStream = fs.createWriteStream(&quot;readMyStreamDesc.txt&quot;);

//El stream de lectura lo pasamos por la función de compresión que crea un stream que lo pasamos al stream de escritura
readStream.pipe(zlib.createGunzip())
          .pipe(writeStream);
</code></pre></p>
<hr />
<h1 id="06-filesfs"><a name="user-content-06-filesfs" href="#06-filesfs" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>06 FIles(fs)</h1>
<h3 id="leer-archivos"><a name="user-content-leer-archivos" href="#leer-archivos" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Leer archivos</h3>
<pre><code>Para leer archivos de forma asincona usamos la función readFile:
</code></pre>
<pre><code>//readfile.js

//Leemos el archivo text.txt y lo enviamos a la consola una vez completada.

//Module for working with files
var fs = require(&quot;fs&quot;);

//Async reading of files. readFile(path, callback).
//Callback receives err and data as input
fs.readFile(&quot;text.txt&quot;, function(err, data){
    if(err){
        return console.error(err);
    }
    //Data es un buffer por lo que hay transformarlo.
    //Encoding default utf8
    console.log(&quot;Los datos del archivo text.txt:&quot;);
    console.log(data.toString());
    console.log(&quot;Fin datos&quot;);
});
</code></pre>

<h3 id="abrir-un-archivo"><a name="user-content-abrir-un-archivo" href="#abrir-un-archivo" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Abrir un archivo:</h3>
<p><pre><code>    fs.open(path, flags, [mode], callback)
</code></pre><br />
        Donde:<br />
            path: archivo a tratar. Si estamos en escritura y el archivo no existe, se crea<br />
            flags: como se abre el archivo:<br />
                r: lectura. Excepción si no existe archivo<br />
                r+: lectura y escritura. Crea una excepción si el archivo no existe<br />
                rs: lectura sincrona<br />
                rs+: lectura y escritura sincrona<br />
                w: escritura. Crea archivo si no existe<br />
                w+: escritura y lectura<br />
                wx, wx+: como w y w+ solo que dan error si el archivo existe<br />
                a: creado para appending<br />
                    ax<br />
                    a+: lectura y appending<br />
            mode: Para casos en los que se crea un archivo, en mode se designa el tipo de privilegios que se le otroga. Por defecto 0666<br />
            callback: recibe error y fd. fd es un numero que identifica al stream y que permite luego cerrarlo.<br />
<pre><code>//openfile.js
//Test de apertura de archivo
//Modulo fs para tratar archivos
var fs = require(&quot;fs&quot;);

//abrir archivo text.txt
fs.open(&quot;text.txt&quot;, &quot;r+&quot;, function(err, fd){
    if(err){
        return console.error(err);
    }
    console.log(&quot;Archivo abierto&quot;);
})
</code></pre></p>
<h3 id="obtener-datos-de-un-archivo"><a name="user-content-obtener-datos-de-un-archivo" href="#obtener-datos-de-un-archivo" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Obtener datos de un archivo:</h3>
<p><pre><code>    fs.stat(path, callback)
</code></pre><br />
        Donde:<br />
            callback recibe err y stats<br />
                donde stats es un objeto con los siguientes métodos:<br />
                    stats.isFile()<br />
                    stats.isDirectory()<br />
                    stats.isBlockDevice()<br />
                    stats.isCharacterDevice()<br />
                    stats.isSimbolicDevice()<br />
                    stats.isFifo()<br />
                    stats.isSocket()<br />
<pre><code>//checkFile.js
//check file
//Modulo fs para trabajar con arcivos
var fs = require(&quot;fs&quot;);

//Fs.stat(path, callback)
fs.stat(&quot;text.txt&quot;, function(err, stats){
    //En caso de error
    if(err){
        return console.error(err);
    }
    //En caso de no error. stats es un objeto:
    console.log(stats); //Objeto stats
    console.log(stats.isFile()); //true
    console.log(stats.isDirectory()); //false
});
</code></pre></p>
<h3 id="escribir-en-un-archivo"><a name="user-content-escribir-en-un-archivo" href="#escribir-en-un-archivo" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Escribir en un archivo:</h3>
<p><pre><code>fs.writeFile(path, data[, options], callback)
</code></pre><br />
            En options es un objeto que podemos pasarle con los keys:<br />
                encoding (utf8 por defecto)<br />
                mode (0666 por defecto)<br />
                flag (w por defecto)<br />
            El callback recibe como inputs err<br />
<pre><code>//writeFile.js
//Escribir con node
//Modulo fs para tratar con archivos
var fs = require(&quot;fs&quot;);

//fs.writefile(path, data[, options], callback)
    //Options obj con claves {encoding , mode, flags}
    //callback con input err
fs.writeFile(   &quot;writetext.txt&quot;, 
                &quot;hola a todos y todas&quot;, 
                {
                    &quot;encoding&quot; :&quot;ascii&quot;,
                    &quot;mode&quot; : &quot;0666&quot;,
                    &quot;flags&quot; : &quot;w&quot;
                },
                function(err){
                    if(err) return console.error(err);
                    console.log(&quot;Data escrita&quot;);
                    //Para leer el archivo:
                    fs.readFile(&quot;writetext.txt&quot;, function(err, data){
                        if(err) return console.error(err);
                        console.log(&quot;Los datos escritos son:&quot;);
                        //data viene raw, codificar a ascii
                        console.log(data.toString(&quot;ascii&quot;));
                    });
                });
</code></pre></p>
<h3 id="lectura-mas-avanzada"><a name="user-content-lectura-mas-avanzada" href="#lectura-mas-avanzada" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Lectura más avanzada</h3>
<pre><code>Otro metodo de lectura más avanzada es el de fs.read(fd, buffer, offset, length, position, callback)
Donde:
        fd - This is the file descriptor returned by file fs.open() method.
        buffer - This is the buffer that the data will be written to.
        offset - This is the offset in the buffer to start writing at.
        length - This is an integer specifying the number of bytes to read.
        position - This is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
        callback - This is the callback function which gets the three arguments, (err, bytesRead, buffer).
</code></pre>
<pre><code>//adRead.js
//Reading files with the read function:
//Modulo fs para leer
var fs = require(&quot;fs&quot;);

//Abrimos el archivo text.txt
//fs.open(path, flags, callback(err, fd))
fs.open(&quot;text.txt&quot;, &quot;r+&quot;, function(err, fd){
    if(err) return console.error(err);
    console.log(&quot;Archivo abierto&quot;);

    //Lectura con read(fd, buffer, offset, length, position, callback)
    //Creamos primero el buffer:
    var buf = new Buffer(256);
    fs.read(fd, buf, 0, 254, null, function(err, bytesRead ){
        if(err) console.error(err);
        //Datos leidos. Archivo utf8. Transdormar raw a utf8
        //Los datos están en el buffer
        //Puede que haya parte del buffer que no ha sido ocupado(como por ejemplo cuando la long es menor que el buf.length)
        //En dicho caso, los elementos adicionale contienen basura.
        //BytesRead nos da el número de bytes leidos:
        console.log(buf.slice(0, bytesRead).toString());
        console.log(&quot;Archivo leido&quot;);
    });
});
</code></pre>

<h3 id="cerrar-archivos"><a name="user-content-cerrar-archivos" href="#cerrar-archivos" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Cerrar archivos.</h3>
<p>Una vez acabado la lectura y cuando no se vaya a usar más el archivo, es conveniente cerrarlo:<br />
<pre><code>    fs.close(fd, callback(err))
</code></pre></p>
<h3 id="truncar-archivos"><a name="user-content-truncar-archivos" href="#truncar-archivos" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Truncar archivos</h3>
<p>Con Truncar archivos estamos pasando a la función ftruncate una longitud de bytes. Eso hace que el archivo abierto y asociado a ftruncate será modificado para que ocupe dicho número de bytes. los que le sobren serán borrados, si le faltan, se le añadiran \0 (nulo en utf8):<br />
<pre><code>//truncate.js
//Abriremos un archivo
//Lo truncaremos y lo volvemos a leer ya truncado
//Modulo fs para tratar con files
var fs = require(&quot;fs&quot;);
var filename = &quot;text2.txt&quot;;

//Opening the file in read/write mode
fs.open(filename, &quot;r+&quot;, function(err, fd){
    if(err) return console.log(err);
    console.log(&quot;Archivo abierto&quot;);
    //Leemos el archivo antes de truncar
    var buf = new Buffer(2048);
    fs.read(fd, buf, 0, buf.length, 0, function(err, bytesRead){
        if(err) return console.log(err);
        console.log(&quot;Archivo leido antes de modificación:&quot;);
        console.log(buf.slice(0, bytesRead).toString());

        if(bytesRead&lt;=5) {
            return console.log(&quot;The file is to small to continue. Put more text.&quot;)
        }
        console.log(&quot;-----BR1&quot; + bytesRead);

        //Hacemos el truncado. La long será lo leido menos 5 bytes
        //ftruncate(fd, len, callback)
        fs.ftruncate(fd, 10, function(err){
            if(err) return console.log(err);
            console.log(&quot;Archivo truncado&quot;);
            //Vamos a leer el archivo truncado:
            console.log(&quot;-----BR2&quot; + (bytesRead-5));
            fs.read(fd, buf, 0, buf.length, 0, function(err, bytesRead2) {
                if(err) return console.log(err);

                console.log(&quot;Leyendo el archivo truncado&quot;);
                console.log(buf.slice(0, bytesRead2).toString());
                console.log(&quot;Archivo Final Leido&quot;);
                fs.close(fd, function(err){
                    if(err) return console.log(err);
                    console.log(&quot;Archivo Cerrado&quot;);
                })
            });
        });


    });

});
</code></pre></p>
<h3 id="eliminar-archivos"><a name="user-content-eliminar-archivos" href="#eliminar-archivos" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Eliminar archivos</h3>
<p>Se usa:<br />
<pre><code>fs.unling(path, callback);
</code></pre><br />
Donde callback solo recibe error como argumento</p>
<h3 id="crear-carpeta"><a name="user-content-crear-carpeta" href="#crear-carpeta" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Crear Carpeta</h3>
<p>Se usa:<br />
<pre><code>fs.mkdir(path[, mode], callback)
</code></pre><br />
Donde path incluye también el nombre de la carpeta<br />
Mode es el código del privilegio de acceso que se le quiere dar<br />
Callback recibe solo err</p>
<h3 id="leer-nombres-de-archivos-y-directorios-en-una-carpeta"><a name="user-content-leer-nombres-de-archivos-y-directorios-en-una-carpeta" href="#leer-nombres-de-archivos-y-directorios-en-una-carpeta" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Leer nombres de archivos y directorios en una carpeta</h3>
<p><pre><code>fs.readdir(path, callback);
</code></pre><br />
Donde callback recibe err y files como argumentos, donde files es un array con todos los nombres de los archivos y directorios</p>
<pre><code>//readdir.js
//Leeremos todos los archivos y carpetas en la carpeta actual

//Modulo fs para trabajar con archivos y carpteas
var fs = require(&quot;fs&quot;);
//Emitter for when we have finished with reading the dir
var events = require(&quot;events&quot;);

//Carpeta actual
var path = &quot;./&quot;;

//Event Emitter
var eventEmitter = new events.EventEmitter();

console.log(&quot;_________________&quot;);
console.log(&quot;Archivos y carpetas en este directorio&quot;);
console.log(&quot;_________________&quot;);

//Arrays that will contain files name and dir names on this folder
var filesCollection = [];
var dirCollecton = [];
var filesAnalyzed = 0;

//Reading folder!
fs.readdir(path, function(err, files){
    if(err) return console.log(err);
    /*  Files is an array that contains all the names of files and folders
        in the directory.
        It doesn't differenciate the files from the folders
        Para separarlo, vamos a usar el módulo stats visto anteriormente
        el cual contiene dos módulos, isFile() e isDirectory() que nos hacen la separación
        El problema de este método es que es asincrono por lo que cuando se ejecutan dichas 
        funciones, la variable i de abajo es igual a files.length para todos los casos.
        Eso hace que filename = files[i] sea siempre el último archivo de files
        Para solucionar ello, estamos haciendo un Inmediate Invocked Function Expression(IIFE)
        en el que creamos un closure al rededor de cada file.stat. De modo, cada closure es única
        para cada llamada y la variable j es igual al i correcto para cada caso ya que es llamado
        en el momento y no de forma asincrona

        Cuando estamos en el último caso, emitimos el evento de &quot;finished_reading_dir&quot; que muestra todas 
        las variables. En vez de la llamada, podiamos haber hecho la llamada a dirColl y fileColl desde 
        dicho if pero estamos usando todo lo que sabemos

    */
    for(var i = 0; i&lt;files.length; i++){
        //Stats tells us if it is a file or a dir
        (function(j){
            //esta función es llamada inmediatamente. Crea una closure donde j es igual al 
            //valor de i correcto de modo que podemos acceder al valor correcto del nombre
            var filename = files[j];
            fs.stat(path+filename, function(err, stats){
                if(stats.isFile()){
                    filesCollection.push(path+filename);
                }
                if(stats.isDirectory()){
                    dirCollecton.push(path+filename);
                }
                //Cuenta el número de archivos que han sido categorizados en dir o file
                filesAnalyzed ++;
                //En el caso de todos los files hayan sido analizados
                if(filesAnalyzed == files.length){
                    eventEmitter.emit(&quot;finished_reading_dir&quot;);
                }
            });
        }(i));  
    }
});

eventEmitter.on(&quot;finished_reading_dir&quot;, function() {
    console.log(&quot;Carpetas:\n&quot;);
    dirCollecton.forEach(function(dirName){
        console.log(dirName);
    });
    console.log(&quot;\n Archivos:&quot;)
    filesCollection.forEach(function(fileName){
        console.log(fileName);
    });
});
</code></pre>

<h3 id="eliminar-directorio"><a name="user-content-eliminar-directorio" href="#eliminar-directorio" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Eliminar directorio</h3>
<p><pre><code>fs.rmdir(path, callback)
</code></pre><br />
Donde callback recibe err</p>
<h3 id="anadir-texto-a-un-archivo"><a name="user-content-anadir-texto-a-un-archivo" href="#anadir-texto-a-un-archivo" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Añadir texto a un archivo</h3>
<p>Con el metodo de writeFile visto anteriormente, cada vez que escribimos sobre un archivo, todo lo que tenía es borrado. <br />
Para añadir texto al final del archivo sin borrar lo anterior usamos appendFile:<br />
<pre><code>    fs.appendFile(path, data [, options], callback)
</code></pre><br />
Donde:<br />
<em> Data es el texto que añadiremos<br />
</em> Options es un objeto con claves &ldquo;encoding&rdquo;, &ldquo;mode&rdquo;, &ldquo;flags&rdquo;<br />
* Callback recibe solo error<br />
<pre><code>//appendData.js
//Cada vez que se llama a este archivo, 
//añade al final del texto la fecha a la que se hizo
//Modulo fs para tratar con archivos
var fs = require(&quot;fs&quot;);

var filepath = &quot;appending.txt&quot;;

//Tiempo actual más salto de linea
var textToAppend = Date() + &quot;\r\n&quot;;

//appendFile, añade textToAppend al final del archivo filepath
fs.appendFile(filepath, textToAppend, function(err) {
    if(err) return console.log(err);
    console.log(&quot;Fecha Añadida!&quot;);
});
</code></pre></p>
<h3 id="otros-metodos-interesantes"><a name="user-content-otros-metodos-interesantes" href="#otros-metodos-interesantes" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Otros métodos interesantes</h3>
<p>Todos asincronos a no ser que diga sync<br />
<pre><code>fs.rename(oldPath, newPath, callback)
fs.chmod(path, mode, callback)
    Cambia el modo de privilegio
fs.link(srcpath, dstpath, callback)
fs.watchFile(filename[, options], listener)
    Listener que se activa cada vez que filename cambia
fs.unwatchFile(filename[, listener])
fs.exists(path, callback)
</code></pre></p>
<p>Más en este <a href="http://www.tutorialspoint.com/nodejs/nodejs_file_system.htm">enlace</a> </p>
<h1 id="07-objetos-globales"><a name="user-content-07-objetos-globales" href="#07-objetos-globales" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>07 Objetos globales</h1>
<p>Se denominan objetos globales a aquellos que se puede acceder en todos los módulos y archivos sin que hayan sido instanciados. NodeJs los crea.<br />
Algunos son:</p>
<h4 id="__filename"><a name="user-content-__filename" href="#__filename" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>__filename</h4>
<p>Nos devuelve el absolute path del archivo llamado<br />
<pre><code>//Filename and dirname
//__filename: devuelve el path completo del archivo llamado
    // D:\Nuevo\Dropbox\WebDesign\node\07_globals\filename.js
console.log( __filename ); 
</code></pre></p>
<h4 id="__dirname"><a name="user-content-__dirname" href="#__dirname" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>__dirname</h4>
<pre><code>// __dirname: devuelve el path del directorio que contiene al archivo llamado
    //D:\Nuevo\Dropbox\WebDesign\node\07_global
console.log( __dirname );
</code></pre>

<h4 id="timers"><a name="user-content-timers" href="#timers" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Timers</h4>
<p>Los ya conocidos:<br />
<pre><code>var timer = setTimeout(callback, t_ms); //Llama a callback despues de t_ms milisegundos
clearTimeout(timer); //Elimina un setTimeout si aún no se ha ejecutado
var interval = setInterval(callback, t_ms); //Llama a callback cada t_ms milisegundos
</code></pre></p>
<h2 id="process"><a name="user-content-process" href="#process" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Process</h2>
<p>El objeto global que contiene datos del proceso de node.<br />
Es un objeto eventEmmiter<br />
Emite los siguientes eventos:<br />
<pre><code>    exit: Cuando  se cierra el proceso. No se puede parar. Da un argumento de exit code al callback.
            Dicho código nos dice si ha habido errores, etc.
    beforeExit: Se lanza cuando no hay mas eventos en el event Loop y va a proceder a exit.
            Se le pueden añadir más llamadas asincronas aumentando el event loop y retrasando la salida
    uncaughtException: Cuando salta un error y no se ha parado. Dicho error aparece en la consola
            pero con este evento se puede frenar
    Otros: sigint, sighup    

</code></pre></p></article></body></html>